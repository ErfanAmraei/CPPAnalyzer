import xml.etree.ElementTree as ElementTree  # Importing the ElementTree module to work with XML files
from strings import CODING_ERROR_MSGS #Importing error messages

class CPPCheck_xmlParser:
    """
    A class to parse XML data generated by CPPCheck and extract specific error information.

    Attributes:
        root (ElementTree.Element): The root element of the parsed XML tree.
        tag (str): The XML tag to search for (e.g., 'errors/error').
        *attributes_SubXMLTag: A variable-length argument list of attribute names to extract from the XML tags.
                         In this case, it will extract 'id', 'msg', 'severity', 'file', 'line', 'location', and 'symbol'.
    """

    def __init__(self, tag, tree, *attributes_SubXMLTag):
        """
        Initializes the CPPCheck_xmlParser with the given XML tree and tag to search for.

        Args:
            tree (ElementTree.ElementTree): The parsed XML tree object.
            tag (str): The tag to search within the XML file (e.g., 'errors/error').
            attributes_SubXMLTag (str): Three strings representing sub-XML tag attributes.
    
        ValueError: If tag is not a string, tree is not an ElementTree object,
                    less or more than 7 attributes are provided, or if any attribute is not a string.
        """
        # Check if tag is a string
        if not isinstance(tag, str):
           raise ValueError(CODING_ERROR_MSGS['tag_err'])
    
        # Check if tree is an instance of ElementTree
        if not isinstance(tree, ElementTree.ElementTree):
            raise ValueError(CODING_ERROR_MSGS['element_tree_err'])
        
        # Check if exactly 3 attributes were provided
        if len(attributes_SubXMLTag) != 7:
            raise ValueError(CODING_ERROR_MSGS['attributes_no_err'])

        # Check if all attributes are strings
        if not all(isinstance(attr, str) for attr in attributes_SubXMLTag):
            raise ValueError(CODING_ERROR_MSGS['attributes_type_err'])
        
        # Get the root element of the XML tree
        self.root = tree.getroot()
        # Store the tag to search for later (e.g., 'errors/error')
        self.parent_Tag = tag
        
        # Set attribute names to class attributes
        self.id = attributes_SubXMLTag[0]  # Attribute to extract error id
        self.msg = attributes_SubXMLTag[1]  # Attribute to extract error message
        self.severity = attributes_SubXMLTag[2]  # Attribute to extract error severity
        self.file = attributes_SubXMLTag[3]  # Attribute to extract file name
        self.line = attributes_SubXMLTag[4]  # Attribute to extract line number
        self.location = attributes_SubXMLTag[5]  # Attribute to extract error location
        self.symbol = attributes_SubXMLTag[6]  # Attribute to extract error symbol
    
    def get_SubXML_Data_Build_Excel_Rows(self, location, symbol, *CPPCheck_data):
        """
        Extracts data from <location> and <symbol> tags and returns error details in a dictionary.
        it forms rows of the final excel file.
        
        Args:
            location (ElementTree.Element): The <location> XML tag.
            symbol (ElementTree.Element): The <symbol> XML tag.
            *CPPCheck_data: Variable-length argument list containing error 'id', 'msg', and 'severity'.
        
        ValueError: less or more than 3 CPPCheck_data are provided, or if any data is not a string.
        
        Returns:
            dict: A dictionary containing error details such as id, message, severity, file, line, and symbol.
        """
        
        # Check if exactly 3 items were provided
        if len(CPPCheck_data) != 3:
            raise ValueError(CODING_ERROR_MSGS['cppcheck_data_no_err'])
        
        # Check if all attributes are strings
        if not all(isinstance(data, str) for data in CPPCheck_data):
            raise ValueError(CODING_ERROR_MSGS['cppcheck_data_type_err'])
        
        # If location and symbol tags are not found, return error data without file and line information
        if location is None and symbol is None:
            errors = {
                self.id: CPPCheck_data[0],  # Extract id
                self.msg: CPPCheck_data[1],  # Extract message
                self.severity: CPPCheck_data[2]  # Extract severity
            }
            return errors
            
        # If location is found but symbol is not, return error data with file and line but without symbol
        elif location is not None and symbol is None:
            # Extract the file path and line number from the <location> tag
            file_path = location.get(self.file)  # Extract file path
            line = location.get(self.line)  # Extract line number
            
            # Append the extracted data as a dictionary
            errors = {
                self.id: CPPCheck_data[0],  # Extract id
                self.msg: CPPCheck_data[1],  # Extract message
                self.severity: CPPCheck_data[2],  # Extract severity
                self.file: file_path,  # Extract file path
                self.line: line  # Extract line number
            }
            return errors
            
        # If both location and symbol are found, return complete error data
        elif location is not None and symbol is not None:
            # Extract the file path and line number from the <location> tag
            file_path = location.get(self.file)  # Extract file path
            line = location.get(self.line)  # Extract line number
            symbol_Text = symbol.text  # Extract symbol text
            
            # Append the extracted data as a dictionary
            errors = {
                self.id: CPPCheck_data[0],  # Extract id
                self.msg: CPPCheck_data[1],  # Extract message
                self.severity: CPPCheck_data[2],  # Extract severity
                self.file: file_path,  # Extract file path
                self.line: line,  # Extract line number
                self.symbol: symbol_Text  # Extract symbol text
            }
            return errors
        
        # If symbol is found but location is not, return symbol data without file and line
        else:
            symbol_Text = symbol.get(self.symbol)  # Extract symbol text
            
            # Append the extracted data as a dictionary
            errors = {
                self.id: CPPCheck_data[0],  # Extract id
                self.msg: CPPCheck_data[1],  # Extract message
                self.severity: CPPCheck_data[2],  # Extract severity
                self.symbol: symbol_Text  # Extract symbol
            }
            return errors
    
    def extract_CPPCheck_Data_from_XML(self):
        """
        Extracts specific attributes_SubXMLTag from XML elements and returns them as a list of dictionaries.

        Returns:
            list: A list of dictionaries containing extracted error information from the XML.
        """
        # Find all XML elements that match the specified tag (e.g., <error> tags within <errors>)
        error_tags = self.root.findall(self.parent_Tag)

        # If there are any <error> tags found in the XML
        if error_tags:
            # Initialize an empty list to hold the extracted data, generated by cppcheck
            errors = []
            # Initialize an empty dictionary to hold the extracted error tag data
            error_tag_data = {}
            
            # Loop through each found <error> tag
            for error in error_tags:
                # Extract the value of the specified attributes_SubXMLTag (e.g., 'id', 'msg', 'severity') from the <error> tag
                error_id = error.get(self.id)  # Extract 'id' attribute of the <error> tag
                error_msg = error.get(self.msg)  # Extract 'msg' attribute (error message) of the <error> tag
                error_severity = error.get(self.severity)  # Extract 'severity' attribute (severity level) of the <error> tag
                
                # Find the <location> tag directly within the <error> tag
                location = error.find(self.location)
                
                # Find the <symbol> tag directly within the <error> tag
                symbol = error.find(self.symbol)
                if "information" not in error_severity:
                    # Call get_SubXML_Data_Build_Excel_Rows method to extract relevant data
                    error_tag_data = self.get_SubXML_Data_Build_Excel_Rows(location, symbol, error_id, error_msg, error_severity)
                    
                    # Append the extracted data to the list
                    errors.append(error_tag_data)
                
            # Return the list of dictionaries containing the error information
            return errors

        else:
            # If no <error> tags are found in the XML, print a message
            print(CODING_ERROR_MSGS['no_err'])